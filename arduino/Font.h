#ifndef FONT_H
#define FONT_H

struct character {
    char character;
    uint8_t ascii_code;
    byte definition[24];
    unsigned short int definition_total_bytes;
};

character findCorrespondingByte(uint8_t ascii_code);

const character characters[] PROGMEM = {
    character{'?', 0x3f, {0x2, 0x1, 0x51, 0x9, 0x6}, 5}, // NOTE: Please do not move question mark from the first (0) :D position. (Developers life depends on it baby)
    character{'C', 0x43, {0x3e, 0x41, 0x41, 0x41, 0x22}, 5},
    character{'H', 0x48, {0x7f, 0x08, 0x08, 0x7f, 0x00}, 5},
    character{'O', 0x4f, {0x3e, 0x41, 0x41, 0x41, 0x3e}, 5},
    character{'-', 0x2d, {0x8, 0x8, 0x8, 0x8, 0x8}, 5},
    character{'!', 0x21 ,{0x5f}, 1},
    character{'.', 0x2e, {0x40}, 1},
    character{'1', 0x31, {0x42, 0x42, 0x7f, 0x40, 0x40}, 5},
    character{'2', 0x32, {0x62, 0x51, 0x49, 0x45, 0x42}, 5},
    character{'3', 0x33, {0x22, 0x41, 0x49, 0x49, 0x3e}, 5},
    character{'4', 0x34, {0x1f, 0x10, 0x7c, 0x10, 0x10}, 5},
    character{'5', 0x35, {0x4f, 0x49, 0x49, 0x49, 0x31}, 5},
    character{'6', 0x36, {0x3e, 0x49, 0x49, 0x49, 0x32}, 5},
    character{'7', 0x37, {0x1, 0x1, 0x79, 0x5, 0x3}, 5},
    character{'8', 0x38, {0x36, 0x49, 0x49, 0x49, 0x36}, 5},
    character{'9', 0x39, {0x26, 0x49, 0x49, 0x49, 0x3e}, 5},
    character{'0', 0x30, {0x3e, 0x41, 0x41, 0x41, 0x3e}, 5},
    character{'+', 0x2b, {0x8, 0x8, 0x3e, 0x8, 0x8}, 5},
    character{':', 0x3a, {0x36, 0x36}, 2},
    character{'=', 0x3d, {0x14, 0x14, 0x14, 0x14, 0x14}, 5},
    character{' ', 0x20, {0x0, 0x0}, 2},
	character{'p', 0x70, {0x7c, 0x14, 0x14, 0x14, 0x8}, 5},
    character{'h', 0x68, {0x7f, 0x8, 0x8, 0x8, 0x70}, 5},
    character{'m', 0x6d, {0x7c, 0x4, 0x7c, 0x4, 0x78}, 5},
    character{'\n', 0x0a, {}, 0},
    character{'\r', 0x0d, {}, 0},
    character{'o', 0x01, {0x00, 0x07, 0x05, 0x07, 0x00}, 5}, // degree symbol
    character{'2', 0x02, {0x00, 0x40, 0x20, 0xc0, 0x00}, 5}, // 2 subscript top
    character{'2', 0x03, {0x00, 0x06, 0x05, 0x04, 0x00}, 5}, // 2 subscript bottom
    // Temperature symbol
    character{'t', 0x04, {0x00, 0x00, 0x00, 0xf8, 0x04, 0x82}, 6}, // t tl
    character{'t', 0x05, {0x04, 0xf8, 0x00, 0x00, 0x00, 0x00}, 6}, // t tr
    character{'t', 0x06, {0x00, 0x00, 0x38, 0x47, 0xb8, 0xbf}, 6}, // t bl
    character{'t', 0x07, {0xb8, 0x47, 0x38, 0x00, 0x00, 0x00}, 6}, // t br
    // Humidity symbol
	// { 0x00,0x00,0x80,0x40,0x3c,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x1e,0x21,0x40,0x40,0x40,0x40,0x40,0x21,0x1e,0x00,0x00,0x00 }
	// { ,,, }
    character{'h', 0x08, {0x00,0x00,0x80,0x40,0x3c,0x40}, 6}, // RH tl
    character{'h', 0x09, {0x80,0x7f,0x11,0x29,0x46,0x00}, 6}, // RH tr
    character{'h', 0x10, {0x1e,0x21,0x40,0x40,0x40,0x40}, 6}, // RH bl
    character{'h', 0x11, {0x40,0x21,0x1e,0x00,0x00,0x00}, 6} // RH br
};


character findCorrespondingByte(uint8_t ascii_code){
    unsigned short int total_characters = sizeof(characters) / sizeof(*characters);
	character temp;
	
    for (unsigned short int i = 0; i < total_characters; i++) {
		//Retrieve character from FLASH MEMORY
		memcpy_P(&temp, &characters[i], sizeof(character));
        if (temp.ascii_code == ascii_code) return temp;
	}
	memcpy_P(&temp, &characters[0], sizeof(character));
    return temp; // if nothing is found, then return question mark (?).
}

#endif

